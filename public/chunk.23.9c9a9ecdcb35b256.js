webpackJsonp([23],{BwGa:function(s,a,r){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var t={render:function(){var s=this,a=s.$createElement,r=s._self._c||a;return r("u-article",[r("h1",[s._v("柯里化与反柯里化")]),r("div",{staticClass:"u-article_meta"},[s._v("2015-06-28")]),r("figure",[r("img",{attrs:{src:"/Skills/Web前端/20170628~柯里化与反柯里化/feature.jpg",alt:""}})]),r("h2",{attrs:{id:"什么是柯里化-"}},[s._v("什么是柯里化？ "),r("a",{staticClass:"header-anchor",attrs:{href:"#什么是柯里化-","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("柯里化来源于数学家Haskell Curry的名字（编程语言Haskell也是以他的名字命名的）。")]),r("blockquote",[r("p",[r("strong",[s._v("柯里化（Curry），又称部分求值（Partial Evaluation）")]),s._v("。其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。")])]),r("h3",{attrs:{id:"典型示例"}},[s._v("典型示例 "),r("a",{staticClass:"header-anchor",attrs:{href:"#典型示例","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("下面是一个部分求和的例子：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" curry = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("func")]),s._v(") =>")]),s._v(" {\n    "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" args = [];\n    "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-title"}},[s._v("result")]),s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("...rest")]),s._v(") ")]),s._v("{\n        "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" (rest.length === "),r("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v(")\n            "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" func(...args);\n\n        args.push(...rest);\n        "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" result;\n    }\n}\n\n"),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" add = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("...args")]),s._v(") =>")]),s._v(" args.reduce("),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("a, b")]),s._v(") =>")]),s._v(" a + b);\n\n"),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" sum = curry(add);\n\nsum("),r("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("1")]),s._v(","),r("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("2")]),s._v(")("),r("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("3")]),s._v(");\nsum("),r("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("4")]),s._v(");\nsum(); "),r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 10")])])]),r("h2",{attrs:{id:"柯里化的基础"}},[s._v("柯里化的基础 "),r("a",{staticClass:"header-anchor",attrs:{href:"#柯里化的基础","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("上面的"),r("code",{pre:!0},[s._v("curry")]),s._v("函数是一个高阶函数（high-order function）。高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新函数。此外，还依赖于闭包的特性，用来保存中间过程中输入的参数。即柯里化的基础：")]),r("ul",[r("li",[s._v("函数可以作为参数传递")]),r("li",[s._v("函数能够作为函数的返回值")]),r("li",[s._v("闭包")])]),r("h2",{attrs:{id:"柯里化的应用"}},[s._v("柯里化的应用 "),r("a",{staticClass:"header-anchor",attrs:{href:"#柯里化的应用","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("h3",{attrs:{id:"1--延迟计算"}},[s._v("1. 延迟计算 "),r("a",{staticClass:"header-anchor",attrs:{href:"#1--延迟计算","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("上面的例子已经很好地说明这一点了。")]),r("h3",{attrs:{id:"2--动态创建函数"}},[s._v("2. 动态创建函数 "),r("a",{staticClass:"header-anchor",attrs:{href:"#2--动态创建函数","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("例如兼容现代浏览器和IE浏览器的添加事件方法，我们通常会这样写：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" addEvent = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("elem, type, fn, cature")]),s._v(") =>")]),s._v(" {\n    "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" ("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("window")]),s._v(".addEventListener) {\n        elem.addEventListener(type, (e) => fn.call(elem, e), capture);\n    } "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("else")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" ("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("window")]),s._v(".attachEvent) {\n        elem.attachEvent("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'on'")]),s._v(" + type, (e) => fn.call(elem, e);\n    }\n}")])]),r("p",[s._v("这种方法显然有个问题，就是每次添加事件处理都要执行一遍"),r("code",{pre:!0},[s._v("if {...} else if {...}")]),s._v("。其实用下面的方法只需判断一次即可：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" addEvent = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("(")]),s._v(") =>")]),s._v(" {\n    "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" ("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("window")]),s._v(".addEventListener) {\n        "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("elem, type, fn, capture")]),s._v(") =>")]),s._v(" {\n            elem.addEventListener(type, (e) => fn.call(elem, e), capture);\n        };\n    } "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("else")]),s._v(" {\n        "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("elem, type, fn, capture")]),s._v(") =>")]),s._v(" {\n            elem.attachEvent("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'on'")]),s._v(" + type, (e) => fn.call(elem, e);\n        };\n    }\n})();")])]),r("p",[s._v("这个例子，第一次"),r("code",{pre:!0},[s._v("if {...} else if {...}")]),s._v("判断之后，完成了部分计算，动态创建新的函数来处理后面传入的参数，以后就不必重新进行计算了。这是一个典型的柯里化应用。")]),r("h3",{attrs:{id:"3--参数复用"}},[s._v("3. 参数复用 "),r("a",{staticClass:"header-anchor",attrs:{href:"#3--参数复用","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("当多次调用同一个函数，并且传递的参数绝大多数是相同的时候，那么该函数就是一个很好的柯里化候选。")]),r("p",[s._v("例如我们经常会用"),r("code",{pre:!0},[s._v("Function.prototype.bind")]),s._v("方法来解决上述问题。")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" obj = { "),r("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("name")]),s._v(": "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'test'")]),s._v(" };\n"),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" foo = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" ("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("prefix, suffix")]),s._v(") ")]),s._v("{\n    "),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("console")]),s._v(".log(prefix + "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".name + suffix);\n}.bind(obj, "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'curry-'")]),s._v(");\n\nfoo("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'-function'")]),s._v("); "),r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// curry-test-function")])])]),r("p",[s._v("与"),r("code",{pre:!0},[s._v("call")]),s._v("/"),r("code",{pre:!0},[s._v("apply")]),s._v("方法直接执行不同，"),r("code",{pre:!0},[s._v("bind")]),s._v("方法将第一个参数设置为函数执行的上下文，其他参数依次传递给调用方法（函数的主体本身不执行，可以看成是延迟执行），并动态创建返回一个新的函数。这很符合柯里化的特征。下面来手动实现一下"),r("code",{pre:!0},[s._v("bind")]),s._v("方法：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.bind = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" ("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("...args")]),s._v(") ")]),s._v("{\n    "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("...rest")]),s._v(") =>")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("this")]),s._v(".call(...args, ...rest);\n};")])]),r("h2",{attrs:{id:"什么是反柯里化-"}},[s._v("什么是反柯里化？ "),r("a",{staticClass:"header-anchor",attrs:{href:"#什么是反柯里化-","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("上面讲了柯里化，我们知道它的主要特点是逐步传参，逐步缩小函数的适用范围。反过来，反柯里化的作用就是扩大函数的适用范围，使本来作为特定对象所拥有的功能的函数可以被任意对象所用。")]),r("p",[s._v("即把如下给定的函数调用形式：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[s._v("obj.func(arg1, arg2);")])]),r("p",[s._v("转化成如下的函数调用形式：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[s._v("func(obj, arg1, arg2);")])]),r("p",[s._v("这就是反柯里化的形式化描述。")]),r("p",[s._v("当然这里有个前提，就是函数"),r("code",{pre:!0},[s._v("func")]),s._v("需要语言上支持"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B",target:"_blank"}},[s._v("鸭子类型")]),s._v("。")]),r("h3",{attrs:{id:"1--最简形式"}},[s._v("1. 最简形式 "),r("a",{staticClass:"header-anchor",attrs:{href:"#1--最简形式","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("用箭头函数可以很简单地实现反柯里化：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" uncurry = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("func")]),s._v(") =>")]),s._v(" (...args) => func.call(...args);\n\n"),r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" split = uncurry("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("String")]),s._v(".prototype.split);\nsplit("),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("'a,b,c'")]),s._v(", "),r("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v("','")]),s._v("); "),r("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// ['a', 'b', 'c']")])])]),r("h3",{attrs:{id:"2--进击的形式"}},[s._v("2. 进击的形式 "),r("a",{staticClass:"header-anchor",attrs:{href:"#2--进击的形式","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("可以看出，"),r("code",{pre:!0},[s._v("uncurry")]),s._v("函数和上面的"),r("code",{pre:!0},[s._v("bind")]),s._v("方法有点神似。下面的形式可以表示出它们与"),r("code",{pre:!0},[s._v("call")]),s._v("方法之间的关系。")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" uncurry = "),r("span",{pre:!0,attrs:{class:"hljs-function"}},[s._v("("),r("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("func")]),s._v(") =>")]),s._v(" "),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.call.bind(func);")])]),r("h3",{attrs:{id:"3--终极形式"}},[s._v("3. 终极形式 "),r("a",{staticClass:"header-anchor",attrs:{href:"#3--终极形式","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("p",[s._v("利用"),r("code",{pre:!0},[s._v("bind")]),s._v("方法可以再剥掉一层，得出反柯里化的终极形式：")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" uncurry = "),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.bind.bind("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.call);")])]),r("p",[s._v("最后以一个反柯里化的"),r("code",{pre:!0},[s._v("bind")]),s._v("函数的终极形式结束，其实就是代入上上个式子得出的结果。")]),r("pre",{pre:!0,attrs:{class:"hljs lang-javascript"}},[r("code",{pre:!0,attrs:{"v-pre":""}},[r("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("const")]),s._v(" bind = "),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.call.bind("),r("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("Function")]),s._v(".prototype.bind);")])]),r("p",[s._v("可见柯里化与反柯里化演绎出了各种JavaScript的奇技淫巧。")]),r("hr"),r("h6",{attrs:{id:"参考"}},[s._v("参考 "),r("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true",target:"_blank"}},[s._v("¶")])]),r("ul",[r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/zztt/p/4142891.html",target:"_blank"}},[s._v("浅析 JavaScript 中的 函数 currying 柯里化")])]),r("li",[r("a",{attrs:{href:"http://www.cnblogs.com/zztt/p/4152147.html",target:"_blank"}},[s._v("浅析 JavaScript 中的 函数 uncurrying 反柯里化")])]),r("li",[r("a",{attrs:{href:"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/",target:"_blank"}},[s._v("JS中的柯里化(currying)")])])]),r("p",{staticClass:"u-article_footer"},[r("span",{staticClass:"u-article_tag"},[s._v("柯里化")]),r("span",{staticClass:"u-article_tag"},[s._v("Curry")]),r("span",{staticClass:"u-article_tag"},[s._v("JavaScript")])])])},staticRenderFns:[]},e=r("OLXp")(null,t,!1,null,null,null);a.default=e.exports}});